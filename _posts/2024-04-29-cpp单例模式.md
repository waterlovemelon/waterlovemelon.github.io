---
layout: post
title: C++单例模式
date: 2024-04-29 22:36 +0800
categories: [c++, 单例模式]
tags: [单例模式]
---

在设计模式中，单例模式应该是使用最广泛的一种设计模式，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

## 为什么要需要单例模式（或者说优点）

- 在程序设计中，有些类只能有一个实例或者最好只有一个对象，从代码层面保证了逻辑的正确性。例如：线程池、文件 IO、全局数据存储对象、网络请求等。
- 能够方便的进行全局访问。单例类通常的使用方式为：SingletonClass::instance()，这代表我们只要包含了类的头文件就可以直接获取到这个类的实例，而不需要进行创建或者通过参数传入，使用非常便捷。如果不是用单例，则需要把这个对象指针到处传递，编写和维护都会比较繁琐。

## 如何实现一个单例类

- 把构造方法设置为 private 方法，避免在外部被创建或者被析构。
- 提供一个 public 的静态方法给外部调用，在静态方法中返回对象的引用或者指针。
- 禁止访问拷贝构造方法、赋值构造方法。

## 常用的单例模式实现

### 饿汉模式

```cpp
class Singleton
{
public:
    static Singleton* GetInstance() {
        return &m_instance;
    }

private:
    Singleton();
    virtual ~Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& opretor=(const Singleton&) = delete;

    static Singleton m_instance;
};

Singleton Singleton::m_instance;  // 在程序入口之前就完成单例对象的初始化
```

饿汉模式的特点是在程序加载完成时就初始化了对象，不需要考虑多线程问题，使用起来简单无脑。但是不支持延迟加载，业务上如果需要完成一些必要操作后再创建对象，饿汉模型就无法满足了。

### 懒汉类型

```cpp
class Singleton
{
public:
    static Singleton* GetInstance() {
        if(nullptr == instance)
            instance = new Singleton();
        return Singleton;
    }

private:
    Singleton();
    virtual ~Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& opretor=(const Singleton&) = delete;

private:
    static Singleton instance* = nullptr;
}
```

懒汉模式的特点是在需要的时候再去创建对象，可以延时创建，很容易满足业务需求，也能够在一定程度降低资源消耗。
但是需要注意，在多线程的场景中，如果两个线程在运行，线程 A 进入后判断对象为空，然后创建对象 A。在对象 A 创建的过程中，线程 B 也调用了`GetInstance`方法，此时`instance`还是空的，于是就创建了对象 B，那么进程中就有了两个对象，单例破防了。

### 双重判断的懒汉类型

```cpp
class Singleton
{
public:
    static Singleton* GetInstance() {
        if(nullptr == instance){
            lock();
            if(nullptr == instance){
                instance = new Singleton();
            }
            unlock();
        }
        return Singleton;
    }

private:
    Singleton();
    virtual ~Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& opretor=(const Singleton&) = delete;

private:
    static Singleton instance* = nullptr;
}
```

对比普通的懒汉类型可以看出，在首次判空后需要加锁才能继续往下走，保证同时只能有一个线程可以创建对象，保证了线程安全。

### 单例模板类

在项目中可能会用到很多单例类，每个类都需要如上声明和定义非常麻烦，身为程序员，偷懒是一个好品质，所以我们需要一个单例模板类。

```cpp
template <typename T>
class Singleton {
private:
    Singleton() = default;;
    virtual ~Singleton() = default;
    Singleton(const T&) = delete;
    Singleton& opretor=(const T&) = delete;

public:
    static T* GetInstance(){
        if(nullptr == instance){
            lock();
            if(nullptr == instance){
                instance = new T();
            }
            unlock();
        }
    }


private:
    static T* instance;
}

template <typename T>
T* Singleton<T>::instance = nullptr;
```

单例模式的类需要把构造函数私有化，但是私有化后，模板类就无法访问到该类的构造函数，也就无法 new T()，需要使用友元类解决这个问题。

```cpp
class Foo : public Singleton<Foo>
{
    friend class Singleton<Foo>;

private:
    Foo();
    ~Foo();
}
```

## 单例的缺点

- 多态性不好。从语法上是可以实现多态的，但是一般多个子类才需要使用多态，创建多个子类对象就不是单例，通常单例类不会被继承。
- 代码扩展性不好。如果后续需求改动或者架构变更需要创建多个对象，可能代码变动会比较大，这个在设计之处就要考虑好。
- 单例一般不能传参。饿汉模型如果要传参则只能是固定参数，那这个传参没什么意义。懒汉模型如果需要传参数则只能从静态方法从传入一个参数，那么只是第一个调用者的参数有用，后面调用者的参数都无用（因为不会再创建对象了），这是一个奇怪的用法。

## 参考链接

https://blog.csdn.net/qq_36256590/article/details/114707991
https://zhuanlan.zhihu.com/p/160835278
